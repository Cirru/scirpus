// Generated by CoffeeScript 1.6.3
var copy_loc, error, expand_assignment_expression, expand_call_expression, expand_identifier, expand_literal, expand_member_expression, expand_variable_declaration, expand_variable_declrator, grammers, is_exp, is_number, is_string, is_token, stringify, tell, tell_from_grammer, tell_from_word, tell_statement, transform, type,
  __slice = [].slice;

type = function(x) {
  var raw;
  raw = Object.prototype.toString.call(x);
  return raw.slice(8, -1).toLowerCase();
};

is_number = function(x) {
  return x >= 0 || x < 0;
};

is_string = function(x) {
  return (type(x)) === "string";
};

stringify = function(x) {
  return JSON.stringify(x);
};

copy_loc = function(word) {
  if ((word.start != null) && (word.end != null)) {
    return {
      start: {
        line: word.start.y + 1,
        column: word.start.x
      },
      end: {
        line: word.end.y + 1,
        column: word.end.x
      }
    };
  } else {
    return null;
  }
};

is_token = function(x) {
  return ((type(x)) === "object") && (is_string(x.text));
};

is_exp = function(x) {
  return (type(x)) === "array";
};

error = function(msg) {
  throw new Error(msg);
};

grammers = {
  ">": function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  },
  "if": function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  },
  ":": function(args) {
    var left, right;
    left = expand_identifier(args[0]);
    right = tell(args[1]);
    return expand_assignment_expression(left, "=", right);
  },
  ".": function(args) {
    var object, property;
    object = expand_identifier(args[0]);
    property = expand_identifier(args[1]);
    return expand_member_expression(object, property);
  },
  "var": function(args) {
    var decs, kind;
    kind = "var";
    decs = args.slice(1).map(function(pair) {
      return pair.map(tell);
    });
    return expand_variable_declaration(decs, kind);
  }
};

expand_literal = function(x) {
  var guess;
  guess = Number(x.text);
  if (is_number(guess)) {
    return {
      type: "Literal",
      value: guess,
      raw: x.text,
      loc: copy_loc(x)
    };
  } else {
    return {
      type: "Literal",
      raw: x.text,
      loc: copy_loc(x)
    };
  }
};

expand_identifier = function(word) {
  return {
    type: "Identifier",
    name: word.text,
    loc: copy_loc(word)
  };
};

expand_assignment_expression = function(left, operator, right) {
  return {
    type: "AssignmentExpression",
    operator: operator,
    left: left,
    right: right
  };
};

expand_call_expression = function(callee, args) {
  return {
    type: "CallExpression",
    callee: callee,
    "arguments": args
  };
};

expand_member_expression = function(object, property) {
  return {
    type: "MemberExpression",
    object: object,
    property: property,
    computed: false
  };
};

expand_variable_declaration = function(decs, kind) {
  return {
    type: "VariableDeclaration",
    declarations: decs.map(function(pair) {
      return expand_variable_declrator(pair[0], pair[1]);
    }),
    kind: kind
  };
};

expand_variable_declrator = function(pattern, init) {
  return {
    type: "VariableDeclarator",
    id: pattern,
    init: init || null
  };
};

tell = function(exp) {
  var args, callee, func;
  if (is_token(exp)) {
    return tell_from_word(exp);
  } else if (is_exp(exp)) {
    func = exp[0];
    if (is_token(func)) {
      return tell_from_grammer(exp);
    } else if (is_exp(func)) {
      callee = tell(func);
      args = exp.slice(1).map(tell);
      return expand_call_expression(callee, args);
    } else {
      return error("" + (stringify(func)) + " not recognized");
    }
  } else {
    return error("bad data..");
  }
};

tell_from_word = function(exp) {
  var text;
  text = exp.text;
  if (text.match(/^[a-zA-Z_\$]/) != null) {
    return expand_identifier(exp);
  } else if (text.match(/^[0-9\/]/)) {
    return expand_literal(exp);
  } else {
    return error("" + (stringify(exp)) + " also not identifier..");
  }
};

tell_from_grammer = function(exp) {
  var func;
  func = exp[0];
  if (grammers[func.text] != null) {
    return grammers[func.text](exp.slice(1));
  } else {
    return error("" + (stringify(func.text)) + " not implemented");
  }
};

tell_statement = function(exp) {
  var head, _ref;
  if (is_exp(exp)) {
    head = exp[0];
    if (is_token(head)) {
      console.log("head...", head.text);
      if ((_ref = head.text) === "var" || _ref === "let") {
        return tell(exp);
      } else {
        return {
          type: "ExpressionStatement",
          expression: tell(exp)
        };
      }
    } else {
      return {
        type: "ExpressionStatement",
        expression: tell(exp)
      };
    }
  } else {
    return error("" + (stringify(exp)) + " not in grammer");
  }
};

transform = function(tree) {
  return {
    type: "Program",
    body: tree.map(tell_statement)
  };
};

exports.transform = transform;
