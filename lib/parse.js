// Generated by CoffeeScript 1.4.0
var err, parse, q, qq, split;

q = "'";

qq = '"';

err = function(info) {
  console.log('error in to_aray');
  throw new Error(info);
};

split = function(source) {
  var c, match, mode, q_esc, qq_esc, reg_esc, tokens, word, _i, _len;
  source = "(" + source + ")";
  mode = 'none';
  reg_esc = false;
  qq_esc = false;
  q_esc = false;
  tokens = [];
  word = '';
  for (_i = 0, _len = source.length; _i < _len; _i++) {
    c = source[_i];
    match = function(char) {
      return char === c;
    };
    if (mode === 'none') {
      if (match('(')) {
        tokens.push('(');
      } else if (match(')')) {
        tokens.push(word);
        word = '';
        tokens.push(')');
      } else if ((match(' ')) || (match('\n'))) {
        if (word.length > 0) {
          tokens.push(word);
        }
        word = '';
      } else if (match(qq)) {
        mode = qq;
        word += qq;
      } else if (match(q)) {
        mode = q;
        word += q;
      } else if (match('/')) {
        mode = '/';
        word += '/';
      } else {
        word += c;
      }
    } else if (mode === '/') {
      word += c;
      if (!reg_esc) {
        if (match('/')) {
          mode = 'none';
        }
      }
      reg_esc = false;
      if (match('\\')) {
        reg_esc = true;
      }
    } else if (mode === qq) {
      word += c;
      if (!qq_esc) {
        if (match(qq)) {
          tokens.push(word);
          word = '';
          mode = 'none';
        }
      }
      qq_esc = false;
      if (match('\\')) {
        qq_esc = true;
      }
    } else if (mode === q) {
      word += c;
      if (!q_esc) {
        if (match(q)) {
          mode = 'none';
          tokens.push(word);
          word = '';
        }
      }
      q_esc = false;
      if (match('\\')) {
        q_esc = true;
      }
    }
  }
  if (reg_esc) {
    err('reg error');
  }
  if (qq_esc) {
    err('qq error');
  }
  if (q_esc) {
    err('q error');
  }
  tokens = tokens.filter(function(item) {
    return item.length > 0;
  });
  return tokens;
};

parse = function(tokens) {
  var busy, len, pos, ret;
  len = tokens.length;
  pos = 1;
  busy = function() {
    var c, tree;
    tree = [];
    while (pos <= len) {
      if (pos === len) {
        err('pos reach len');
      }
      c = tokens[pos];
      pos += 1;
      if (c === '(') {
        tree.push(busy());
      } else if (c === ')') {
        return tree;
      } else {
        tree.push(c);
      }
    }
  };
  ret = busy();
  return ret;
};

exports.parse = function(source) {
  return parse(split(source));
};
